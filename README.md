# 项目未成型，感兴趣watch追踪进度

# 架构类基础知识看这里 https://github.com/xjjdog/javaok



概念抽象：

## actor 秒杀参与者  
根据字面意思，就能够看到这里抽象的是操作的主体，也就是参与的人。actor会带有一些附着信息，比如用户的一些基本信息。这样，就能够实现一些个体的流控策略，或者风控策略。举个例子，假如有一个逻辑：最新注册的账号没有秒杀资格。那么actor的附加信息里，就应该包含用户的注册时间。

## queue 缓冲队列  
队列是秒杀请求的缓冲，是首先落地的地方。无论是内存队列，还是分布式队列，其实操作起来都是差不多的。我们也对其进行一下抽象。这样，通过配置参数，就可以调节秒杀队列的行为和性能。

## source 秒杀数据源  
数据的提供者。数据可能来源于一个外部的数据库(db)，也可能来自于外部的推送(push)，也可能来自于外部接口的拉取(pull)。这个数据获取的过程，我们就给它起个名字，叫做source。当然，这部分的功能也是可以扩展的，比如source数据来自ES。

## sink 秒杀数据落地下沉
主要处理秒杀完成后，数据的去向。与source类似，它是一个反向的动作。处理的是类似库存扣减一类的落地动作。这个组件的行为，或许是推送，也或许是直接发送一个事件消息。source和sink，组成了一个秒杀目标的具体数据流向，是黑盒之外的东西。

## target 秒杀目标
是时候给秒杀目标起个名字了。它拥有一个在秒杀引擎中唯一的名字：targetID，用来标识是哪一种商品。非常非常多的个性化配置参数，就在这里，比如秒杀开始时间，队列长度，是否懒加载商品等。

## stock 库存操作
库存操作指的是在黑盒之内的操作，这些信息会不定期的进行合并，sink到业务端。对stock的操作，就需要保证其正确性和吞吐量。这也是我们的核心概念之一。

## action 动作
类似消息总线的作用。动作，action，指的是actor所产生的所有行为的载体，在整个生命周期中，是不可变的（Immutable）。动作会被缓冲，追踪，调度，记录，是穿插整个引擎的行为实体。

## runtime 实时运行单元
runtime是变化的，用于秒杀混沌期的信息缓冲，原则上不会记录和下沉。我们的运行单元会做很多运算和判断，直到最终的数据，达到`BASE`的状态。
